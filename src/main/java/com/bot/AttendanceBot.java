package com.bot;

import io.github.cdimascio.dotenv.Dotenv;
import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Location;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.WeekFields;
import java.util.*;

public class AttendanceBot extends TelegramLongPollingBot {

    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss");
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    private static final String BOT_TOKEN;
    private static final String BOT_USERNAME;

    private final MongoDBService mongoService;
    private final Map<Long, String> waitingForLocation = new HashMap<>(); // L∆∞u tr·∫°ng th√°i ch·ªù location

    static {
        Dotenv dotenv = Dotenv.load();
        BOT_TOKEN = dotenv.get("BOT_TOKEN");
        BOT_USERNAME = dotenv.get("BOT_USERNAME");
    }

    public AttendanceBot() {
        this.mongoService = MongoDBService.getInstance();
    }

    @Override
    public String getBotUsername() {
        return BOT_USERNAME;
    }

    @Override
    public String getBotToken() {
        return BOT_TOKEN;
    }

    @Override
    public void onUpdateReceived(Update update) {
        if (update.hasMessage() && update.getMessage().hasText()) {
            handleTextMessage(update);
        } else if (update.hasMessage() && update.getMessage().hasLocation()) {
            handleLocationMessage(update);
        } else if (update.hasCallbackQuery()) {
            handleCallbackQuery(update);
        }
    }

    private static final Set<Long> ADMIN_IDS = new HashSet<>(Arrays.asList(
            7909720025L, 6736326571L
    ));

    private void handleTextMessage(Update update) {
        String messageText = update.getMessage().getText();
        long chatId = update.getMessage().getChatId();
        Long userId = update.getMessage().getFrom().getId();
        String username = update.getMessage().getFrom().getUserName();

        if (username == null || username.isEmpty()) {
            username = "user_" + userId;
        }

        switch (messageText) {
            case "/start":
                sendWelcomeMessage(chatId);
                break;
            case "/checkin":
                requestLocationForCheckin(chatId, userId, username);
                break;
            case "/checkout":
                requestLocationForCheckout(chatId, userId, username);
                break;
            case "/today":
                handleTodayStats(chatId, userId);
                break;
            case "/week":
                handleWeekStats(chatId, userId);
                break;
            case "/alltoday":
                handleAllTodayStats(chatId, userId);
                break;
            case "/allweek":
                handleAllWeekStats(chatId, userId);
                break;
            case "/allmonth":
                handleAllMonthStats(chatId, userId);
                break;
            default:
                sendMessage(chatId, "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng /start ƒë·ªÉ xem c√°c ch·ª©c nƒÉng.");
        }
    }

    private void handleLocationMessage(Update update) {
        long chatId = update.getMessage().getChatId();
        Long userId = update.getMessage().getFrom().getId();
        String username = update.getMessage().getFrom().getUserName();
        Location location = update.getMessage().getLocation();

        if (username == null || username.isEmpty()) {
            username = "user_" + userId;
        }

        String action = waitingForLocation.getOrDefault(userId, "");

        if ("checkin".equals(action)) {
            handleCheckinWithLocation(chatId, userId, username, location);
            waitingForLocation.remove(userId);
        } else if ("checkout".equals(action)) {
            handleCheckoutWithLocation(chatId, userId, username, location);
            waitingForLocation.remove(userId);
        }
    }

    private void handleCallbackQuery(Update update) {
        String callbackData = update.getCallbackQuery().getData();
        long chatId = update.getCallbackQuery().getMessage().getChatId();
        Long userId = update.getCallbackQuery().getFrom().getId();
        String username = update.getCallbackQuery().getFrom().getUserName();

        if (username == null || username.isEmpty()) {
            username = "user_" + userId;
        }

        switch (callbackData) {
            case "checkin":
                requestLocationForCheckin(chatId, userId, username);
                break;
            case "checkout":
                requestLocationForCheckout(chatId, userId, username);
                break;
        }

        try {
            org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery answer =
                    new org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery();
            answer.setCallbackQueryId(update.getCallbackQuery().getId());
            execute(answer);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void sendWelcomeMessage(long chatId) {
        String welcomeText = "üëã Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Bot Ch·∫•m C√¥ng!\n\n" +
                "üìã C√°c ch·ª©c nƒÉng c√° nh√¢n:\n" +
                "üìç Checkin - B·∫Øt ƒë·∫ßu l√†m vi·ªác\n" +
                "üîì Checkout - K·∫øt th√∫c ng√†y l√†m vi·ªác\n" +
                "üìä /today - Xem th·ªëng k√™ h√¥m nay\n" +
                "üìà /week - Xem th·ªëng k√™ tu·∫ßn n√†y\n\n";

        if (chatId > 0 && ADMIN_IDS.contains(chatId)) {
            welcomeText += "üë®‚Äçüíº C√°c l·ªánh Admin:\n" +
                    "üìä /alltoday - Th·ªëng k√™ t·∫•t c·∫£ nh√¢n vi√™n h√¥m nay\n" +
                    "üìà /allweek - Th·ªëng k√™ t·∫•t c·∫£ nh√¢n vi√™n tu·∫ßn n√†y\n" +
                    "üìÖ /allmonth - Th·ªëng k√™ t·∫•t c·∫£ nh√¢n vi√™n th√°ng n√†y\n\n";
        }

        welcomeText += "üíæ D·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr√™n MongoDB (k√®m v·ªã tr√≠ GPS)\n\n" +
                "Ch·ªçn ch·ª©c nƒÉng b√™n d∆∞·ªõi:";

        sendMessageWithKeyboard(chatId, welcomeText);
    }

    private InlineKeyboardMarkup createInlineKeyboard() {
        InlineKeyboardMarkup markup = new InlineKeyboardMarkup();
        List<List<InlineKeyboardButton>> keyboard = new ArrayList<>();

        List<InlineKeyboardButton> row1 = new ArrayList<>();
        InlineKeyboardButton checkinBtn = new InlineKeyboardButton();
        checkinBtn.setText("üìç Checkin");
        checkinBtn.setCallbackData("checkin");
        row1.add(checkinBtn);

        InlineKeyboardButton checkoutBtn = new InlineKeyboardButton();
        checkoutBtn.setText("üîì Checkout");
        checkoutBtn.setCallbackData("checkout");
        row1.add(checkoutBtn);

        keyboard.add(row1);
        markup.setKeyboard(keyboard);

        return markup;
    }

    private void requestLocationForCheckin(long chatId, Long userId, String username) {
        waitingForLocation.put(userId, "checkin");

        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("üìç Vui l√≤ng chia s·∫ª v·ªã tr√≠ hi·ªán t·∫°i c·ªßa b·∫°n ƒë·ªÉ checkin");

        ReplyKeyboardMarkup keyboard = new ReplyKeyboardMarkup();
        keyboard.setOneTimeKeyboard(true);
        keyboard.setResizeKeyboard(true);

        List<KeyboardRow> rows = new ArrayList<>();
        KeyboardRow row = new KeyboardRow();
        KeyboardButton button = new KeyboardButton();
        button.setText("üìç G·ª≠i v·ªã tr√≠ hi·ªán t·∫°i");
        button.setRequestLocation(true);
        row.add(button);
        rows.add(row);

        keyboard.setKeyboard(rows);
        message.setReplyMarkup(keyboard);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void requestLocationForCheckout(long chatId, Long userId, String username) {
        waitingForLocation.put(userId, "checkout");

        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("üìç Vui l√≤ng chia s·∫ª v·ªã tr√≠ hi·ªán t·∫°i c·ªßa b·∫°n ƒë·ªÉ checkout");

        ReplyKeyboardMarkup keyboard = new ReplyKeyboardMarkup();
        keyboard.setOneTimeKeyboard(true);
        keyboard.setResizeKeyboard(true);

        List<KeyboardRow> rows = new ArrayList<>();
        KeyboardRow row = new KeyboardRow();
        KeyboardButton button = new KeyboardButton();
        button.setText("üìç G·ª≠i v·ªã tr√≠ hi·ªán t·∫°i");
        button.setRequestLocation(true);
        row.add(button);
        rows.add(row);

        keyboard.setKeyboard(rows);
        message.setReplyMarkup(keyboard);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void handleCheckinWithLocation(long chatId, Long userId, String username, Location location) {
        LocalDateTime now = LocalDateTime.now();
        LocalDate today = now.toLocalDate();

        AttendanceRecord existingRecord = mongoService.getTodayRecord(userId, today);

        if (existingRecord != null && existingRecord.getCheckinTime() != null) {
            sendMessage(chatId, "‚ö†Ô∏è B·∫°n ƒë√£ checkin h√¥m nay l√∫c " +
                    existingRecord.getCheckinTime().format(TIME_FORMATTER) + "\n" +
                    "üìç V·ªã tr√≠: " + existingRecord.getCheckinAddress());
            return;
        }

        AttendanceRecord record = new AttendanceRecord(userId, username, today, now, null, 0.0);
        record.setCheckinLatitude(location.getLatitude());
        record.setCheckinLongitude(location.getLongitude());
        record.setCheckinAddress(getLocation(location.getLatitude(), location.getLongitude()));

        mongoService.saveOrUpdateRecord(record);

        String responseText = "‚úÖ Checkin th√†nh c√¥ng l√∫c " + now.format(TIME_FORMATTER) + "\n" +
                "üìç V·ªã tr√≠: " + record.getCheckinAddress() + "\n" +
                "üîì Nh·∫•n \"Checkout\" khi b·∫°n k·∫øt th√∫c ng√†y l√†m vi·ªác";

        sendMessageWithKeyboard(chatId, responseText);
    }

    private void handleCheckoutWithLocation(long chatId, Long userId, String username, Location location) {
        LocalDateTime now = LocalDateTime.now();
        LocalDate today = now.toLocalDate();

        AttendanceRecord record = mongoService.getTodayRecord(userId, today);

        if (record == null || record.getCheckinTime() == null) {
            sendMessage(chatId, "‚ö†Ô∏è B·∫°n ch∆∞a checkin h√¥m nay. Vui l√≤ng checkin tr∆∞·ªõc!");
            return;
        }

        if (record.getCheckoutTime() != null) {
            sendMessage(chatId, "‚ö†Ô∏è B·∫°n ƒë√£ checkout r·ªìi l√∫c " +
                    record.getCheckoutTime().format(TIME_FORMATTER) + "\n" +
                    "üìç V·ªã tr√≠: " + record.getCheckoutAddress());
            return;
        }

        record.setCheckoutTime(now);
        record.setCheckoutLatitude(location.getLatitude());
        record.setCheckoutLongitude(location.getLongitude());
        record.setCheckoutAddress(getLocation(location.getLatitude(), location.getLongitude()));

        Duration duration = Duration.between(record.getCheckinTime(), record.getCheckoutTime());
        record.setTotalHours(duration.toMinutes() / 60.0);

        mongoService.saveOrUpdateRecord(record);

        String responseText = "üîì Checkout th√†nh c√¥ng l√∫c " + now.format(TIME_FORMATTER) + "\n" +
                "üìç V·ªã tr√≠: " + record.getCheckoutAddress() + "\n" +
                "‚è± T·ªïng th·ªùi gian l√†m vi·ªác h√¥m nay: " +
                String.format("%.2f gi·ªù", record.getTotalHours());

        sendMessage(chatId, responseText);
    }

    private String getLocation(Double latitude, Double longitude) {
        return GeoService.getAddressFromCoordinates(latitude, longitude);
//        return String.format("%.4f, %.4f", latitude, longitude);
    }

    private void handleTodayStats(long chatId, Long userId) {
        LocalDate today = LocalDate.now();
        AttendanceRecord record = mongoService.getTodayRecord(userId, today);

        if (record == null || record.getCheckinTime() == null) {
            sendMessage(chatId, "üìä Ch∆∞a c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng h√¥m nay.");
            return;
        }

        StringBuilder stats = new StringBuilder();
        stats.append("üìä TH·ªêNG K√ä H√îM NAY (").append(today.format(DATE_FORMATTER)).append(")\n\n");
        stats.append("üìç Checkin: ").append(record.getCheckinTime().format(TIME_FORMATTER)).append("\n");
        stats.append("   V·ªã tr√≠: ").append(record.getCheckinAddress()).append("\n\n");

        if (record.getCheckoutTime() != null) {
            stats.append("üîì Checkout: ").append(record.getCheckoutTime().format(TIME_FORMATTER)).append("\n");
            stats.append("   V·ªã tr√≠: ").append(record.getCheckoutAddress()).append("\n\n");
            stats.append("‚è± T·ªïng gi·ªù: ").append(String.format("%.2f gi·ªù", record.getTotalHours()));
        } else {
            stats.append("üîì Checkout: Ch∆∞a checkout\n");
            Duration currentDuration = Duration.between(record.getCheckinTime(), LocalDateTime.now());
            double currentHours = currentDuration.toMinutes() / 60.0;
            stats.append("‚è± ƒê√£ l√†m: ").append(String.format("%.2f gi·ªù", currentHours)).append(" (ƒëang l√†m vi·ªác)");
        }

        sendMessage(chatId, stats.toString());
    }

    private void handleWeekStats(long chatId, Long userId) {
        LocalDate today = LocalDate.now();
        WeekFields weekFields = WeekFields.of(Locale.getDefault());
        int currentWeek = today.get(weekFields.weekOfWeekBasedYear());

        List<AttendanceRecord> weekRecords = mongoService.getWeekRecords(userId, today);

        if (weekRecords.isEmpty()) {
            sendMessage(chatId, "üìà Ch∆∞a c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng tu·∫ßn n√†y.");
            return;
        }

        StringBuilder stats = new StringBuilder();
        stats.append("üìà TH·ªêNG K√ä TU·∫¶N N√ÄY (Tu·∫ßn ").append(currentWeek).append(")\n\n");

        double totalWeekHours = 0.0;
        int workDays = 0;

        for (AttendanceRecord record : weekRecords) {
            stats.append("üìÖ ").append(record.getDate().format(DATE_FORMATTER)).append("\n");
            stats.append("   üìç In: ").append(record.getCheckinTime().format(TIME_FORMATTER));
            stats.append(" (").append(record.getCheckinAddress()).append(")");

            if (record.getCheckoutTime() != null) {
                stats.append("\n   üîì Out: ").append(record.getCheckoutTime().format(TIME_FORMATTER));
                stats.append(" (").append(record.getCheckoutAddress()).append(")");
                stats.append("\n   ‚è± ").append(String.format("%.2fh", record.getTotalHours()));
                totalWeekHours += record.getTotalHours();
                workDays++;
            } else {
                stats.append("\n   üîì Ch∆∞a checkout");
            }
            stats.append("\n\n");
        }

        stats.append("üìä T·ªïng k·∫øt:\n");
        stats.append("   ‚Ä¢ S·ªë ng√†y l√†m: ").append(workDays).append("\n");
        stats.append("   ‚Ä¢ T·ªïng gi·ªù: ").append(String.format("%.2f gi·ªù", totalWeekHours)).append("\n");
        if (workDays > 0) {
            stats.append("   ‚Ä¢ TB/ng√†y: ").append(String.format("%.2f gi·ªù", totalWeekHours / workDays));
        }

        sendMessage(chatId, stats.toString());
    }

    private void sendMessage(long chatId, String text) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText(text);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void sendMessageWithKeyboard(long chatId, String text) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText(text);
        message.setReplyMarkup(createInlineKeyboard());

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private boolean isAdmin(Long userId) {
        return ADMIN_IDS.contains(userId);
    }

    private void handleAllTodayStats(long chatId, Long userId) {
        if (!isAdmin(userId)) {
            sendMessage(chatId, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
            return;
        }

        LocalDate today = LocalDate.now();
        List<AttendanceRecord> allRecords = mongoService.getAllRecordsForDate(today);

        if (allRecords.isEmpty()) {
            sendMessage(chatId, "üìä Ch∆∞a c√≥ ai checkin h√¥m nay.");
            return;
        }

        StringBuilder stats = new StringBuilder();
        stats.append("üìä TH·ªêNG K√ä T·∫§T C·∫¢ NH√ÇN VI√äN H√îM NAY\n");
        stats.append("üìÖ ").append(today.format(DATE_FORMATTER)).append("\n");
        stats.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");

        double totalHours = 0.0;
        int checkedIn = 0;
        int checkedOut = 0;

        for (AttendanceRecord record : allRecords) {
            stats.append("üë§ ").append(record.getUsername()).append("\n");
            stats.append("   üìç In: ").append(record.getCheckinTime().format(TIME_FORMATTER));
            stats.append(" (").append(record.getCheckinAddress()).append(")");

            if (record.getCheckoutTime() != null) {
                stats.append("\n   üîì Out: ").append(record.getCheckoutTime().format(TIME_FORMATTER));
                stats.append(" (").append(record.getCheckoutAddress()).append(")");
                stats.append("\n   ‚è± ").append(String.format("%.2fh", record.getTotalHours()));
                totalHours += record.getTotalHours();
                checkedOut++;
            } else {
                Duration currentDuration = Duration.between(record.getCheckinTime(), LocalDateTime.now());
                double currentHours = currentDuration.toMinutes() / 60.0;
                stats.append("\n   ‚è± ").append(String.format("%.2fh", currentHours)).append(" (ƒëang l√†m)");
            }
            stats.append("\n\n");
            checkedIn++;
        }

        stats.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        stats.append("üìà T·ªîNG K·∫æT:\n");
        stats.append("   ‚Ä¢ ƒê√£ checkin: ").append(checkedIn).append(" ng∆∞·ªùi\n");
        stats.append("   ‚Ä¢ ƒê√£ checkout: ").append(checkedOut).append(" ng∆∞·ªùi\n");
        stats.append("   ‚Ä¢ T·ªïng gi·ªù: ").append(String.format("%.2fh", totalHours));

        sendMessage(chatId, stats.toString());
    }

    private void handleAllWeekStats(long chatId, Long userId) {
        if (!isAdmin(userId)) {
            sendMessage(chatId, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
            return;
        }

        LocalDate today = LocalDate.now();
        WeekFields weekFields = WeekFields.of(Locale.getDefault());
        int currentWeek = today.get(weekFields.weekOfWeekBasedYear());

        List<AttendanceRecord> allRecords = mongoService.getAllRecordsForWeek(today);

        if (allRecords.isEmpty()) {
            sendMessage(chatId, "üìà Ch∆∞a c√≥ d·ªØ li·ªáu tu·∫ßn n√†y.");
            return;
        }

        Map<String, List<AttendanceRecord>> userRecords = new HashMap<>();
        for (AttendanceRecord record : allRecords) {
            userRecords.computeIfAbsent(record.getUsername(), k -> new ArrayList<>()).add(record);
        }

        StringBuilder stats = new StringBuilder();
        stats.append("üìà TH·ªêNG K√ä T·∫§T C·∫¢ NH√ÇN VI√äN TU·∫¶N N√ÄY\n");
        stats.append("üìÖ Tu·∫ßn ").append(currentWeek).append("\n");
        stats.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");

        double grandTotalHours = 0.0;

        for (Map.Entry<String, List<AttendanceRecord>> entry : userRecords.entrySet()) {
            String username = entry.getKey();
            List<AttendanceRecord> records = entry.getValue();

            double userTotalHours = 0.0;
            int workDays = 0;

            stats.append("üë§ ").append(username).append("\n");

            for (AttendanceRecord record : records) {
                if (record.getCheckoutTime() != null) {
                    userTotalHours += record.getTotalHours();
                    workDays++;
                }
            }

            stats.append("   ‚Ä¢ S·ªë ng√†y: ").append(workDays).append("\n");
            stats.append("   ‚Ä¢ T·ªïng gi·ªù: ").append(String.format("%.2fh", userTotalHours)).append("\n");
            if (workDays > 0) {
                stats.append("   ‚Ä¢ TB/ng√†y: ").append(String.format("%.2fh", userTotalHours / workDays)).append("\n");
            }
            stats.append("\n");

            grandTotalHours += userTotalHours;
        }

        stats.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        stats.append("üìä T·ªîNG K·∫æT TO√ÄN B·ªò:\n");
        stats.append("   ‚Ä¢ T·ªïng nh√¢n vi√™n: ").append(userRecords.size()).append("\n");
        stats.append("   ‚Ä¢ T·ªïng gi·ªù l√†m: ").append(String.format("%.2fh", grandTotalHours));

        sendMessage(chatId, stats.toString());
    }

    private void handleAllMonthStats(long chatId, Long userId) {
        if (!isAdmin(userId)) {
            sendMessage(chatId, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
            return;
        }

        LocalDate today = LocalDate.now();
        int currentMonth = today.getMonthValue();
        int currentYear = today.getYear();

        List<AttendanceRecord> allRecords = mongoService.getAllRecordsForMonth(today);

        if (allRecords.isEmpty()) {
            sendMessage(chatId, "üìÖ Ch∆∞a c√≥ d·ªØ li·ªáu th√°ng n√†y.");
            return;
        }

        Map<String, List<AttendanceRecord>> userRecords = new HashMap<>();
        for (AttendanceRecord record : allRecords) {
            userRecords.computeIfAbsent(record.getUsername(), k -> new ArrayList<>()).add(record);
        }

        StringBuilder stats = new StringBuilder();
        stats.append("üìÖ TH·ªêNG K√ä T·∫§T C·∫¢ NH√ÇN VI√äN TH√ÅNG N√ÄY\n");
        stats.append("üìÜ Th√°ng ").append(currentMonth).append("/").append(currentYear).append("\n");
        stats.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");

        double grandTotalHours = 0.0;

        List<Map.Entry<String, List<AttendanceRecord>>> sortedUsers = new ArrayList<>(userRecords.entrySet());
        sortedUsers.sort((a, b) -> {
            double totalA = a.getValue().stream()
                    .filter(r -> r.getCheckoutTime() != null)
                    .mapToDouble(AttendanceRecord::getTotalHours)
                    .sum();
            double totalB = b.getValue().stream()
                    .filter(r -> r.getCheckoutTime() != null)
                    .mapToDouble(AttendanceRecord::getTotalHours)
                    .sum();
            return Double.compare(totalB, totalA);
        });

        for (Map.Entry<String, List<AttendanceRecord>> entry : sortedUsers) {
            String username = entry.getKey();
            List<AttendanceRecord> records = entry.getValue();

            double userTotalHours = 0.0;
            int workDays = 0;

            stats.append("üë§ ").append(username).append("\n");

            for (AttendanceRecord record : records) {
                if (record.getCheckoutTime() != null) {
                    userTotalHours += record.getTotalHours();
                    workDays++;
                }
            }

            stats.append("   ‚Ä¢ S·ªë ng√†y: ").append(workDays).append("\n");
            stats.append("   ‚Ä¢ T·ªïng gi·ªù: ").append(String.format("%.2fh", userTotalHours)).append("\n");
            if (workDays > 0) {
                stats.append("   ‚Ä¢ TB/ng√†y: ").append(String.format("%.2fh", userTotalHours / workDays)).append("\n");
            }
            stats.append("\n");

            grandTotalHours += userTotalHours;
        }

        stats.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        stats.append("üìä T·ªîNG K·∫æT TO√ÄN B·ªò:\n");
        stats.append("   ‚Ä¢ T·ªïng nh√¢n vi√™n: ").append(userRecords.size()).append("\n");
        stats.append("   ‚Ä¢ T·ªïng gi·ªù l√†m: ").append(String.format("%.2fh", grandTotalHours));
        if (!userRecords.isEmpty()) {
            stats.append("\n   ‚Ä¢ TB/ng∆∞·ªùi: ").append(String.format("%.2fh", grandTotalHours / userRecords.size()));
        }

        sendMessage(chatId, stats.toString());
    }
}
